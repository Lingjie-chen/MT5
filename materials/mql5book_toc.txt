--- Page 1 ---
© 2000-2024, M etaQuotes Ltd

--- Page 2 ---
Contents
2Contents
MQL5 Programming for Traders
13
..................................................................................................................................................................................................... 1 5
1
Part 1 . Introduction to MQL5 and development environment
......................................................................................................................................................................................1 6
1 .1  Editing, compiling, and running programs
......................................................................................................................................................................................1 9
1 .2 MQL Wizard and program draft
......................................................................................................................................................................................22
1 .3 Statements, code blocks, and functions
......................................................................................................................................................................................24
1 .4 First program
......................................................................................................................................................................................26
1 .5 Data types and values
......................................................................................................................................................................................28
1 .6 Variables and identifiers
......................................................................................................................................................................................29
1 .7 Assignment and initialization, expressions and arrays
......................................................................................................................................................................................31 
1 .8 Data input
......................................................................................................................................................................................33
1 .9 Error fixing and debugging
......................................................................................................................................................................................37
1 .1 0 Data output
......................................................................................................................................................................................39
1 .1 1  Formatting, indentation, and spaces
......................................................................................................................................................................................41 
1 .1 2 Mini summary
..................................................................................................................................................................................................... 42
2
Part 2. Programming fundamentals
......................................................................................................................................................................................43
2.1  Identifiers
......................................................................................................................................................................................44
2.2 Built-in data types
.............................................................................................................................................................................. 46
2.2.1  Integers
.............................................................................................................................................................................. 50
2.2.2 Floating-point numbers
.............................................................................................................................................................................. 53
2.2.3 Character types
.............................................................................................................................................................................. 54
2.2.4 String type
.............................................................................................................................................................................. 55
2.2.5 Logic (Boolean) type
.............................................................................................................................................................................. 56
2.2.6 Date and time
.............................................................................................................................................................................. 57
2.2.7 Color
.............................................................................................................................................................................. 58
2.2.8 Enumerations
.............................................................................................................................................................................. 61 
2.2.9 Custom enumerations
.............................................................................................................................................................................. 64
2.2.1 0 Void type
......................................................................................................................................................................................64
2.3 Variables
.............................................................................................................................................................................. 65
2.3.1  Declaration and definition of variables
.............................................................................................................................................................................. 66
2.3.2 Context, scope, and lifetime of variables
.............................................................................................................................................................................. 68
2.3.3 Initialization
.............................................................................................................................................................................. 74
2.3.4 Static variables
.............................................................................................................................................................................. 76
2.3.5 Constant variables
.............................................................................................................................................................................. 77
2.3.6 Input variables
.............................................................................................................................................................................. 78
2.3.7 External variables
......................................................................................................................................................................................81 
2.4 Arrays
.............................................................................................................................................................................. 82
2.4.1  Array characteristics
.............................................................................................................................................................................. 83
2.4.2 Description of arrays
.............................................................................................................................................................................. 85
2.4.3 Using arrays
......................................................................................................................................................................................88
2.5 Expressions
.............................................................................................................................................................................. 88
2.5.1  Basic concepts
.............................................................................................................................................................................. 90
2.5.2 Assignment operation
.............................................................................................................................................................................. 92
2.5.3 Arithmetic operations
.............................................................................................................................................................................. 94
2.5.4 Increment and decrement
.............................................................................................................................................................................. 95
2.5.5 Comparison operations
.............................................................................................................................................................................. 97
2.5.6 Logical operations
.............................................................................................................................................................................. 98
2.5.7 Bitwise operations
.............................................................................................................................................................................. 1 00
2.5.8 Modification operations
.............................................................................................................................................................................. 1 02
2.5.9 Conditional ternary operator
.............................................................................................................................................................................. 1 04
2.5.1 0 Comma
.............................................................................................................................................................................. 1 04
2.5.1 1  Special operators sizeof and typename

--- Page 3 ---
Contents
3.............................................................................................................................................................................. 1 06
2.5.1 2 Grouping with parentheses
.............................................................................................................................................................................. 1 06
2.5.1 3 Priorities of operations
......................................................................................................................................................................................1 08
2.6 Type conversion
.............................................................................................................................................................................. 1 09
2.6.1 . Implicit type conversion
.............................................................................................................................................................................. 1 1 0
2.6.2. Arithmetic type conversions
.............................................................................................................................................................................. 1 1 2
2.6.3. Explicit type conversion
......................................................................................................................................................................................1 1 3
2.7 Statements
.............................................................................................................................................................................. 1 1 4
2.7.1  Compound statements (blocks of code)
.............................................................................................................................................................................. 1 1 4
2.7.2 Declaration/definition statements
.............................................................................................................................................................................. 1 1 8
2.7.3 Simple statements (expressions)
.............................................................................................................................................................................. 1 1 9
2.7.4 Overview of control statements
.............................................................................................................................................................................. 1 20
2.7.5 For loop
.............................................................................................................................................................................. 1 24
2.7.6 While loop
.............................................................................................................................................................................. 1 26
2.7.7 Do loop
.............................................................................................................................................................................. 1 26
2.7.8 If selection
.............................................................................................................................................................................. 1 29
2.7.9 Switch selection
.............................................................................................................................................................................. 1 32
2.7.1 0 Break jump
.............................................................................................................................................................................. 1 35
2.7.1 1  Continue jump
.............................................................................................................................................................................. 1 36
2.7.1 2 Return jump
.............................................................................................................................................................................. 1 36
2.7.1 3 Empty statement
......................................................................................................................................................................................1 37
2.8 Functions
.............................................................................................................................................................................. 1 38
2.8.1  Function definition
.............................................................................................................................................................................. 1 39
2.8.2 Function call
.............................................................................................................................................................................. 1 40
2.8.3 Parameters and arguments
.............................................................................................................................................................................. 1 41 
2.8.4 Value parameters and reference parameters
.............................................................................................................................................................................. 1 44
2.8.5 Optional parameters
.............................................................................................................................................................................. 1 45
2.8.6 Return values
.............................................................................................................................................................................. 1 46
2.8.7 Function declaration
.............................................................................................................................................................................. 1 47
2.8.8 Recursion
.............................................................................................................................................................................. 1 48
2.8.9 Function overloading
.............................................................................................................................................................................. 1 50
2.8.1 0 Function pointers (typedef)
.............................................................................................................................................................................. 1 53
2.8.1 1  Inlining
......................................................................................................................................................................................1 53
2.9 Preprocessor
.............................................................................................................................................................................. 1 54
2.9.1  Including source files (#include)
.............................................................................................................................................................................. 1 55
2.9.2 Overview of macro substitution directives
.............................................................................................................................................................................. 1 56
2.9.3 Simple form of #define
.............................................................................................................................................................................. 1 58
2.9.4 Form of #define as a pseudo-function
.............................................................................................................................................................................. 1 61 
2.9.5 Special operators '#' and '##' inside #define definitions
.............................................................................................................................................................................. 1 62
2.9.6 Cancelling macro substitution (#undef)
.............................................................................................................................................................................. 1 62
2.9.7 Predefined preprocessor constants
.............................................................................................................................................................................. 1 63
2.9.8 Conditional compilation (#ifdef/#ifndef/#else/#endif)
.............................................................................................................................................................................. 1 64
2.9.9 General program properties (#property)
..................................................................................................................................................................................................... 1 66
3
Part 3. Object Oriented Programming
......................................................................................................................................................................................1 66
3.1  Structures and unions
.............................................................................................................................................................................. 1 67
3.1 .1  Definition of structures
.............................................................................................................................................................................. 1 69
3.1 .2 Functions (methods) in structures
.............................................................................................................................................................................. 1 70
3.1 .3 Copying structures
.............................................................................................................................................................................. 1 71 
3.1 .4 Constructors and destructors
.............................................................................................................................................................................. 1 74
3.1 .5 Packing structures in memory and interacting with DLLs
.............................................................................................................................................................................. 1 75
3.1 .6 Structure layout and inheritance
.............................................................................................................................................................................. 1 77
3.1 .7 Access rights
.............................................................................................................................................................................. 1 78
3.1 .8 Unions
......................................................................................................................................................................................1 80
3.2 Classes and interfaces
.............................................................................................................................................................................. 1 80
3.2.1  OOP fundamentals: Abstraction
.............................................................................................................................................................................. 1 81 
3.2.2 OOP fundamentals: Encapsulation
.............................................................................................................................................................................. 1 82
3.2.3 OOP fundamentals: Inheritance

--- Page 4 ---
Contents
4.............................................................................................................................................................................. 1 83
3.2.4 OOP fundamentals: Polymorphism
.............................................................................................................................................................................. 1 83
3.2.5 OOP fundamentals: Composition (design)
.............................................................................................................................................................................. 1 84
3.2.6 Class definition
.............................................................................................................................................................................. 1 87
3.2.7 Access rights
.............................................................................................................................................................................. 1 88
3.2.8 Constructors: default, parametric, and copying
.............................................................................................................................................................................. 1 94
3.2.9 Destructors
.............................................................................................................................................................................. 1 95
3.2.1 0 Self-reference: this
.............................................................................................................................................................................. 1 98
3.2.1 1  Inheritance
.............................................................................................................................................................................. 203
3.2.1 2 Dynamic creation of objects: new and delete
.............................................................................................................................................................................. 205
3.2.1 3 Pointers
.............................................................................................................................................................................. 21 1 
3.2.1 4 Virtual methods (virtual and override)
.............................................................................................................................................................................. 220
3.2.1 5 Static members
.............................................................................................................................................................................. 222
3.2.1 6 Nested types, namespaces, and the context operator '::'
.............................................................................................................................................................................. 226
3.2.1 7 Splitting class declaration and definition
.............................................................................................................................................................................. 229
3.2.1 8 Abstract classes and interfaces
.............................................................................................................................................................................. 231 
3.2.1 9 Operator overloading
.............................................................................................................................................................................. 242
3.2.20 Object type сasting: dynamic_cast and pointer void *
.............................................................................................................................................................................. 246
3.2.21  Pointers, references, and const
.............................................................................................................................................................................. 250
3.2.22 Inheritance management: final and delete
......................................................................................................................................................................................251 
3.3 Templates
.............................................................................................................................................................................. 252
3.3.1  Template header
.............................................................................................................................................................................. 253
3.3.2 General template operation principles
.............................................................................................................................................................................. 255
3.3.3 Templates vs preprocessor macros
.............................................................................................................................................................................. 256
3.3.4 Features of built-in and object types in templates
.............................................................................................................................................................................. 260
3.3.5 Function templates
.............................................................................................................................................................................. 265
3.3.6 Object type templates
.............................................................................................................................................................................. 270
3.3.7 Method templates
.............................................................................................................................................................................. 276
3.3.8 Nested templates
.............................................................................................................................................................................. 277
3.3.9 Absent template specialization
..................................................................................................................................................................................................... 281 
4
Part 4. Common APIs
......................................................................................................................................................................................281 
4.1  Built-in type conversions
.............................................................................................................................................................................. 282
4.1 .1  Numbers to strings and vice versa
.............................................................................................................................................................................. 286
4.1 .2 Normalization of doubles
.............................................................................................................................................................................. 287
4.1 .3 Date and time
.............................................................................................................................................................................. 296
4.1 .4 Color
.............................................................................................................................................................................. 299
4.1 .5 Structures
.............................................................................................................................................................................. 301 
4.1 .6 Enumerations
.............................................................................................................................................................................. 303
4.1 .7 Type complex
......................................................................................................................................................................................304
4.2 Working with strings and symbols
.............................................................................................................................................................................. 305
4.2.1  Initialization and measurement of strings
.............................................................................................................................................................................. 309
4.2.2 String concatenation
.............................................................................................................................................................................. 31 0
4.2.3 String comparison
.............................................................................................................................................................................. 31 6
4.2.4 Changing the character case and trimming spaces
.............................................................................................................................................................................. 31 8
4.2.5 Finding, replacing, and extracting string fragments
.............................................................................................................................................................................. 322
4.2.6 Working with symbols and code pages
.............................................................................................................................................................................. 329
4.2.7 Universal formatted data output to a string
......................................................................................................................................................................................335
4.3 Working with arrays
.............................................................................................................................................................................. 336
4.3.1  Logging arrays
.............................................................................................................................................................................. 339
4.3.2 Dynamic arrays
.............................................................................................................................................................................. 346
4.3.3 Array measurement
.............................................................................................................................................................................. 347
4.3.4 Initializing and populating arrays
.............................................................................................................................................................................. 349
4.3.5 Copying and editing arrays
.............................................................................................................................................................................. 361 
4.3.6 Moving (swapping) arrays
.............................................................................................................................................................................. 363
4.3.7 Comparing, sorting, and searching in arrays
.............................................................................................................................................................................. 378
4.3.8 Timeseries indexing direction in arrays
.............................................................................................................................................................................. 382
4.3.9 Zeroing objects and arrays

--- Page 5 ---
Contents
5......................................................................................................................................................................................387
4.4 Mathematical functions
.............................................................................................................................................................................. 388
4.4.1  The absolute value of a number
.............................................................................................................................................................................. 390
4.4.2 Maximum and minimum of two numbers
.............................................................................................................................................................................. 390
4.4.3 Rounding functions
.............................................................................................................................................................................. 391 
4.4.4 Remainder after division (Modulo operation)
.............................................................................................................................................................................. 392
4.4.5 Powers and roots
.............................................................................................................................................................................. 392
4.4.6 Exponential and logarithmic functions
.............................................................................................................................................................................. 394
4.4.7 Trigonometric functions
.............................................................................................................................................................................. 397
4.4.8 Hyperbolic functions
.............................................................................................................................................................................. 398
4.4.9 Normality test for real numbers
.............................................................................................................................................................................. 401 
4.4.1 0 Random number generation
.............................................................................................................................................................................. 402
4.4.1 1  Endianness control in integers
......................................................................................................................................................................................404
4.5 Working with files
.............................................................................................................................................................................. 406
4.5.1  Information storage methods: text and binary
.............................................................................................................................................................................. 408
4.5.2 Writing and reading files in simplified mode
.............................................................................................................................................................................. 41 2
4.5.3 Opening and closing files
.............................................................................................................................................................................. 41 8
4.5.4 Managing file descriptors
.............................................................................................................................................................................. 425
4.5.5 Selecting an encoding for text mode
.............................................................................................................................................................................. 428
4.5.6 Writing and reading arrays
.............................................................................................................................................................................. 433
4.5.7 Writing and reading structures (binary files)
.............................................................................................................................................................................. 438
4.5.8 Writing and reading variables (binary files)
.............................................................................................................................................................................. 446
4.5.9 Writing and reading variables (text files)
.............................................................................................................................................................................. 455
4.5.1 0 Managing position in a file
.............................................................................................................................................................................. 461 
4.5.1 1  Getting file properties
.............................................................................................................................................................................. 465
4.5.1 2 Force write cache to disk
.............................................................................................................................................................................. 470
4.5.1 3 Deleting a file and checking if it exists
.............................................................................................................................................................................. 472
4.5.1 4 Copying and moving files
.............................................................................................................................................................................. 474
4.5.1 5 Searching for files and folders
.............................................................................................................................................................................. 476
4.5.1 6 Working with folders
.............................................................................................................................................................................. 478
4.5.1 7 File or folder selection dialog
......................................................................................................................................................................................482
4.6 Client terminal global variables
.............................................................................................................................................................................. 483
4.6.1  Writing and reading global variables
.............................................................................................................................................................................. 485
4.6.2 Checking the existence and last activity time
.............................................................................................................................................................................. 486
4.6.3 Getting a list of global variables
.............................................................................................................................................................................. 487
4.6.4 Deleting global variables
.............................................................................................................................................................................. 488
4.6.5 Temporary global variables
.............................................................................................................................................................................. 489
4.6.6 Synchronizing programs using global variables
.............................................................................................................................................................................. 499
4.6.7 Flushing global variables to disk
......................................................................................................................................................................................500
4.7 Functions for working with time
.............................................................................................................................................................................. 502
4.7.1  Local and server time
.............................................................................................................................................................................. 505
4.7.2 Daylight saving time (local)
.............................................................................................................................................................................. 51 1 
4.7.3 Universal Time
.............................................................................................................................................................................. 51 1 
4.7.4 Pausing a program
.............................................................................................................................................................................. 51 2
4.7.5 Time interval counters
......................................................................................................................................................................................51 3
4.8 User interaction
.............................................................................................................................................................................. 51 4
4.8.1  Logging messages
.............................................................................................................................................................................. 51 8
4.8.2 Alerts
.............................................................................................................................................................................. 51 9
4.8.3 Displaying messages in the chart window
.............................................................................................................................................................................. 523
4.8.4 Message dialog box
.............................................................................................................................................................................. 528
4.8.5 Sound alerts
......................................................................................................................................................................................529
4.9 MQL program execution environment
.............................................................................................................................................................................. 530
4.9.1  Getting a general list of terminal and program properties
.............................................................................................................................................................................. 534
4.9.2 Terminal build number
.............................................................................................................................................................................. 534
4.9.3 Program type and license
.............................................................................................................................................................................. 536
4.9.4 Terminal and program operating modes
.............................................................................................................................................................................. 538
4.9.5 Permissions

--- Page 6 ---
Contents
6.............................................................................................................................................................................. 541 
4.9.6 Checking network connections
.............................................................................................................................................................................. 543
4.9.7 Computing resources: memory, disk, and CPU
.............................................................................................................................................................................. 544
4.9.8 Screen specifications
.............................................................................................................................................................................. 546
4.9.9 Terminal and program string properties
.............................................................................................................................................................................. 548
4.9.1 0 Custom properties: Bar limit and interface language
.............................................................................................................................................................................. 548
4.9.1 1  Binding a program to runtime properties
.............................................................................................................................................................................. 558
4.9.1 2 Checking keyboard status
.............................................................................................................................................................................. 560
4.9.1 3 Checking the MQL program status and reason for termination
.............................................................................................................................................................................. 562
4.9.1 4 Programmatically closing the terminal and setting a return code
.............................................................................................................................................................................. 564
4.9.1 5 Handling runtime errors
.............................................................................................................................................................................. 566
4.9.1 6 User-defined errors
.............................................................................................................................................................................. 571 
4.9.1 7 Debug management
.............................................................................................................................................................................. 571 
4.9.1 8 Predefined variables
.............................................................................................................................................................................. 572
4.9.1 9 Predefined constants of the MQL5 language
......................................................................................................................................................................................574
4.1 0 Matrices and vectors
.............................................................................................................................................................................. 574
4.1 0.1  Types of matrices and vectors
.............................................................................................................................................................................. 576
4.1 0.2 Creating and initializing matrices and vectors
.............................................................................................................................................................................. 579
4.1 0.3 Copying matrices, vectors, and arrays
.............................................................................................................................................................................. 581 
4.1 0.4 Copying timeseries to matrices and vectors
.............................................................................................................................................................................. 582
4.1 0.5 Copying tick history to matrices and vectors
.............................................................................................................................................................................. 583
4.1 0.6 Evaluation of expressions with matrices and vectors
.............................................................................................................................................................................. 584
4.1 0.7 Manipulating matrices and vectors
.............................................................................................................................................................................. 588
4.1 0.8 Products of matrices and vectors
.............................................................................................................................................................................. 590
4.1 0.9 Transformations (decomposition) of matrices
.............................................................................................................................................................................. 592
4.1 0.1 0 Obtaining statistics
.............................................................................................................................................................................. 593
4.1 0.1 1  Characteristics of matrices and vectors
.............................................................................................................................................................................. 595
4.1 0.1 2 Solving equations
.............................................................................................................................................................................. 601 
4.1 0.1 3 Machine learning methods
..................................................................................................................................................................................................... 61 1 
5
Part 5. Creating application programs
......................................................................................................................................................................................61 2
5.1  General principles for executing MQL programs
.............................................................................................................................................................................. 61 3
5.1 .1  Designing MQL programs of various types
.............................................................................................................................................................................. 61 6
5.1 .2 Threads
.............................................................................................................................................................................. 61 7
5.1 .3 Overview of event handling functions
.............................................................................................................................................................................. 623
5.1 .4 Features of starting and stopping programs of various types
.............................................................................................................................................................................. 626
5.1 .5 Reference events of indicators and Expert Advisors: OnInit and OnDeinit
.............................................................................................................................................................................. 628
5.1 .6 The main function of scripts and services: OnStart
.............................................................................................................................................................................. 629
5.1 .7 Programmatic removal of Expert Advisors and scripts: ExpertRemove
......................................................................................................................................................................................631 
5.2 Scripts and services
.............................................................................................................................................................................. 631 
5.2.1  Scripts
.............................................................................................................................................................................. 632
5.2.2 Services
.............................................................................................................................................................................. 636
5.2.3 Restrictions for scripts and services
......................................................................................................................................................................................637
5.3 Timeseries
.............................................................................................................................................................................. 639
5.3.1  Symbols and timeframes
.............................................................................................................................................................................. 642
5.3.2 Technical aspects of timeseries organization and storage
.............................................................................................................................................................................. 643
5.3.3 Getting characteristics of price arrays
.............................................................................................................................................................................. 645
5.3.4 Number of available bars (Bars/iBars)
.............................................................................................................................................................................. 645
5.3.5 Search bar index by time (iBarShift)
.............................................................................................................................................................................. 648
5.3.6 Overview of Copy functions for obtaining arrays of quotes
.............................................................................................................................................................................. 652
5.3.7 Getting quotes as an array of MqlRates structures
.............................................................................................................................................................................. 655
5.3.8 Separate request for arrays of prices, volumes, spreads, time
.............................................................................................................................................................................. 657
5.3.9 Reading price, volume, spread, and time by bar index
.............................................................................................................................................................................. 660
5.3.1 0 Finding the maximum and minimum values in a timeseries
.............................................................................................................................................................................. 664
5.3.1 1  Working with real tick arrays in MqlTick structures
......................................................................................................................................................................................675
5.4 Creating custom indicators
.............................................................................................................................................................................. 675
5.4.1  Main characteristics of indicators
.............................................................................................................................................................................. 676
5.4.2 Main indicator event: OnCalculate

--- Page 7 ---
Contents
7.............................................................................................................................................................................. 680
5.4.3 Two types of indicators: for main window and subwindow
.............................................................................................................................................................................. 681 
5.4.4 Setting the number of buffers and graphic plots
.............................................................................................................................................................................. 682
5.4.5 Assigning an array as a buffer: SetIndexBuffer
.............................................................................................................................................................................. 685
5.4.6 Plot settings: PlotIndexSetInteger
.............................................................................................................................................................................. 691 
5.4.7 Buffer and chart mapping rules
.............................................................................................................................................................................. 695
5.4.8 Applying directives to customize plots
.............................................................................................................................................................................. 697
5.4.9 Setting plot names
.............................................................................................................................................................................. 698
5.4.1 0 Visualizing data gaps (empty elements)
.............................................................................................................................................................................. 704
5.4.1 1  Indicators in separate subwindows: sizes and levels
.............................................................................................................................................................................. 71 0
5.4.1 2 General properties of indicators: title and value accuracy
.............................................................................................................................................................................. 71 1 
5.4.1 3 Item-wise chart coloring
.............................................................................................................................................................................. 71 4
5.4.1 4 Skip drawing on initial bars
.............................................................................................................................................................................. 720
5.4.1 5 Waiting for data and managing visibility (DRAW_NONE)
.............................................................................................................................................................................. 732
5.4.1 6 Multicurrency and multitimeframe indicators
.............................................................................................................................................................................. 754
5.4.1 7 Tracking bar formation
.............................................................................................................................................................................. 757
5.4.1 8 Testing indicators
.............................................................................................................................................................................. 759
5.4.1 9 Limitations and advantages of indicators
.............................................................................................................................................................................. 760
5.4.20 Creating an indicator draft in the MQL Wizard
......................................................................................................................................................................................762
5.5 Using ready-made indicators from MQL programs
.............................................................................................................................................................................. 763
5.5.1  Handles and counters of indicator owners
.............................................................................................................................................................................. 765
5.5.2 A simple way to create indicator instances: iCustom
.............................................................................................................................................................................. 768
5.5.3 Checking the number of calculated bars: BarsCalculated
.............................................................................................................................................................................. 770
5.5.4 Getting timeseries data from an indicator: CopyBuffer
.............................................................................................................................................................................. 780
5.5.5 Support for multiple symbols and timeframes
.............................................................................................................................................................................. 786
5.5.6 Overview of built-in indicators
.............................................................................................................................................................................. 792
5.5.7 Using built-in indicators
.............................................................................................................................................................................. 801 
5.5.8 Advanced way to create indicators: IndicatorCreate
.............................................................................................................................................................................. 81 2
5.5.9 Flexible creation of indicators with IndicatorCreate
.............................................................................................................................................................................. 820
5.5.1 0 Overview of functions managing indicators on the chart
.............................................................................................................................................................................. 821 
5.5.1 1  Combining output to main and auxiliary windows
.............................................................................................................................................................................. 824
5.5.1 2 Reading data from charts that have a shift
.............................................................................................................................................................................. 827
5.5.1 3 Deleting indicator instances: IndicatorRelease
.............................................................................................................................................................................. 832
5.5.1 4 Getting indicator settings by its handle
.............................................................................................................................................................................. 835
5.5.1 5 Defining data source for an indicator
......................................................................................................................................................................................836
5.6 Working with timer
.............................................................................................................................................................................. 837
5.6.1  Turning timer on and off
.............................................................................................................................................................................. 838
5.6.2 Timer event: OnTimer
.............................................................................................................................................................................. 847
5.6.3 High-precision timer: EventSetMillisecondTimer
......................................................................................................................................................................................849
5.7 Working with charts
.............................................................................................................................................................................. 850
5.7.1  Functions for getting the basic properties of the current chart
.............................................................................................................................................................................. 851 
5.7.2 Chart identification
.............................................................................................................................................................................. 852
5.7.3 Getting the list of charts
.............................................................................................................................................................................. 853
5.7.4 Getting the symbol and timeframe of an arbitrary chart
.............................................................................................................................................................................. 854
5.7.5 Overview of functions for working with the complete set of properties
.............................................................................................................................................................................. 856
5.7.6 Descriptive chart properties
.............................................................................................................................................................................. 858
5.7.7 Checking the status of the main window
.............................................................................................................................................................................. 858
5.7.8 Getting the number and visibility of windows/subwindows
.............................................................................................................................................................................. 860
5.7.9 Chart display modes
.............................................................................................................................................................................. 868
5.7.1 0 Managing the visibility of chart elements
.............................................................................................................................................................................. 872
5.7.1 1  Horizontal shifts
.............................................................................................................................................................................. 873
5.7.1 2 Horizontal scale (by time)
.............................................................................................................................................................................. 875
5.7.1 3 Vertical scale (by price and indicator readings)
.............................................................................................................................................................................. 878
5.7.1 4 Colors
.............................................................................................................................................................................. 881 
5.7.1 5 Mouse and keyboard control
.............................................................................................................................................................................. 884
5.7.1 6 Undocking chart window
.............................................................................................................................................................................. 885
5.7.1 7 Getting MQL program drop coordinates on a chart

--- Page 8 ---
Contents
8.............................................................................................................................................................................. 887
5.7.1 8 Translation of screen coordinates to time/price and vice versa
.............................................................................................................................................................................. 890
5.7.1 9 Scrolling charts along the time axis
.............................................................................................................................................................................. 893
5.7.20 Chart redraw request
.............................................................................................................................................................................. 894
5.7.21  Switching symbol and timeframe
.............................................................................................................................................................................. 894
5.7.22 Managing indicators on the chart
.............................................................................................................................................................................. 900
5.7.23 Opening and closing charts
.............................................................................................................................................................................. 903
5.7.24 Working with tpl chart templates
.............................................................................................................................................................................. 91 8
5.7.25 Saving a chart image
......................................................................................................................................................................................921 
5.8 Graphical objects
.............................................................................................................................................................................. 922
5.8.1  Object types and features of specifying their coordinates
.............................................................................................................................................................................. 923
5.8.2 Time and price bound objects
.............................................................................................................................................................................. 925
5.8.3 Objects bound to screen coordinates
.............................................................................................................................................................................. 925
5.8.4 Creating objects
.............................................................................................................................................................................. 928
5.8.5 Deleting objects
.............................................................................................................................................................................. 930
5.8.6 Finding objects
.............................................................................................................................................................................. 934
5.8.7 Overview of object property access functions
.............................................................................................................................................................................. 952
5.8.8 Main object properties
.............................................................................................................................................................................. 953
5.8.9 Price and time coordinates
.............................................................................................................................................................................. 956
5.8.1 0 Anchor window corner and screen coordinates
.............................................................................................................................................................................. 960
5.8.1 1  Defining anchor point on the object
.............................................................................................................................................................................. 962
5.8.1 2 Managing the object state
.............................................................................................................................................................................. 963
5.8.1 3 Priority of objects (Z-Order)
.............................................................................................................................................................................. 966
5.8.1 4 Object display settings: color, style, and frame
.............................................................................................................................................................................. 979
5.8.1 5 Font settings
.............................................................................................................................................................................. 982
5.8.1 6 Rotating text at an arbitrary angle
.............................................................................................................................................................................. 984
5.8.1 7 Determining object width and height
.............................................................................................................................................................................. 991 
5.8.1 8 Visibility of objects in the context of timeframes
.............................................................................................................................................................................. 994
5.8.1 9 Assigning a character code to a label
.............................................................................................................................................................................. 995
5.8.20 Ray properties for objects with straight lines
.............................................................................................................................................................................. 998
5.8.21  Managing object pressed state
.............................................................................................................................................................................. 1 000
5.8.22 Adjusting images in bitmap objects
.............................................................................................................................................................................. 1 001 
5.8.23 Cropping (outputting part) of an image
.............................................................................................................................................................................. 1 004
5.8.24 Input field properties: alignment and read-only
.............................................................................................................................................................................. 1 006
5.8.25 Standard deviation channel width
.............................................................................................................................................................................. 1 006
5.8.26 Setting levels in level objects
.............................................................................................................................................................................. 1 01 0
5.8.27 Additional properties of Gann, Fibonacci, and Elliot objects
.............................................................................................................................................................................. 1 01 1 
5.8.28 Chart object
.............................................................................................................................................................................. 1 01 5
5.8.29 Moving objects
.............................................................................................................................................................................. 1 01 6
5.8.30 Getting time or price at the specified line points
......................................................................................................................................................................................1 020
5.9 Interactive events on charts
.............................................................................................................................................................................. 1 021 
5.9.1  Event handling function OnChartEvent
.............................................................................................................................................................................. 1 023
5.9.2 Event-related chart properties
.............................................................................................................................................................................. 1 025
5.9.3 Chart change event
.............................................................................................................................................................................. 1 027
5.9.4 Keyboard events
.............................................................................................................................................................................. 1 036
5.9.5 Mouse events
.............................................................................................................................................................................. 1 039
5.9.6 Graphical object events
.............................................................................................................................................................................. 1 043
5.9.7 Generation of custom events
..................................................................................................................................................................................................... 1 049
6
Part 6. Trading automation
......................................................................................................................................................................................1 049
6.1  Financial instruments and Market Watch
.............................................................................................................................................................................. 1 050
6.1 .1  Getting available symbols and Market Watch lists
.............................................................................................................................................................................. 1 051 
6.1 .2 Editing the Market Watch list
.............................................................................................................................................................................. 1 054
6.1 .3 Checking if a symbol exists
.............................................................................................................................................................................. 1 055
6.1 .4 Checking the symbol data relevance
.............................................................................................................................................................................. 1 057
6.1 .5 Getting the last tick of a symbol
.............................................................................................................................................................................. 1 061 
6.1 .6 Schedules of trading and quoting sessions
.............................................................................................................................................................................. 1 066
6.1 .7 Symbol margin rates

--- Page 9 ---
Contents
9.............................................................................................................................................................................. 1 067
6.1 .8 Overview of functions for getting symbol properties
.............................................................................................................................................................................. 1 076
6.1 .9 Checking symbol status
.............................................................................................................................................................................. 1 077
6.1 .1 0 Price type for building symbol charts
.............................................................................................................................................................................. 1 083
6.1 .1 1  Base, quote, and margin currencies of the instrument
.............................................................................................................................................................................. 1 090
6.1 .1 2 Price representation accuracy and change steps
.............................................................................................................................................................................. 1 093
6.1 .1 3 Permitted volumes of trading operations
.............................................................................................................................................................................. 1 096
6.1 .1 4 Trading permission
.............................................................................................................................................................................. 1 1 00
6.1 .1 5 Symbol trading conditions and order execution modes
.............................................................................................................................................................................. 1 1 04
6.1 .1 6 Margin requirements
.............................................................................................................................................................................. 1 1 1 2
6.1 .1 7 Pending order expiration rules
.............................................................................................................................................................................. 1 1 1 7
6.1 .1 8 Spreads and order distance from the current price
.............................................................................................................................................................................. 1 1 21 
6.1 .1 9 Getting swap sizes
.............................................................................................................................................................................. 1 1 26
6.1 .20 Current market information (tick)
.............................................................................................................................................................................. 1 1 28
6.1 .21  Descriptive symbol properties
.............................................................................................................................................................................. 1 1 31 
6.1 .22 Depth of Market
.............................................................................................................................................................................. 1 1 33
6.1 .23 Custom symbol properties
.............................................................................................................................................................................. 1 1 34
6.1 .24 Specific properties (stock exchange, derivatives, bonds)
......................................................................................................................................................................................1 1 35
6.2 Depth of Market
.............................................................................................................................................................................. 1 1 36
6.2.1  Managing subscriptions to Depth of Market events
.............................................................................................................................................................................. 1 1 38
6.2.2 Receiving events about changes in the Depth of Market
.............................................................................................................................................................................. 1 1 40
6.2.3 Reading the current Depth of Market data
.............................................................................................................................................................................. 1 1 47
6.2.4 Using Depth of Market data in applied algorithms
......................................................................................................................................................................................1 1 55
6.3 Trading account information
.............................................................................................................................................................................. 1 1 56
6.3.1  Overview of functions for getting account properties
.............................................................................................................................................................................. 1 1 59
6.3.2 Identifying the account, client, server, and broker
.............................................................................................................................................................................. 1 1 60
6.3.3 Account type: real, demo or contest
.............................................................................................................................................................................. 1 1 61 
6.3.4 Account currency
.............................................................................................................................................................................. 1 1 61 
6.3.5 Account type: netting or hedging
.............................................................................................................................................................................. 1 1 62
6.3.6 Restrictions and permissions for account operations
.............................................................................................................................................................................. 1 1 65
6.3.7 Account margin settings
.............................................................................................................................................................................. 1 1 68
6.3.8 Current financial performance of the account
......................................................................................................................................................................................1 1 69
6.4 Creating Expert Advisors
.............................................................................................................................................................................. 1 1 70
6.4.1  Expert Advisors main event: OnTick
.............................................................................................................................................................................. 1 1 72
6.4.2 Basic principles and concepts: order, deal, and position
.............................................................................................................................................................................. 1 1 73
6.4.3 Types of trading operations
.............................................................................................................................................................................. 1 1 74
6.4.4 Order types
.............................................................................................................................................................................. 1 1 76
6.4.5 Order execution modes by price and volume
.............................................................................................................................................................................. 1 1 77
6.4.6 Pending order expiration dates
.............................................................................................................................................................................. 1 1 78
6.4.7 Margin calculation for a future order: OrderCalcMargin
.............................................................................................................................................................................. 1 1 90
6.4.8 Estimating the profit of a trading operation: OrderCalcProfit
.............................................................................................................................................................................. 1 1 96
6.4.9 MqlTradeRequest structure
.............................................................................................................................................................................. 1 1 99
6.4.1 0 MqlTradeCheckResult structure
.............................................................................................................................................................................. 1 201 
6.4.1 1  Request validation: OrderCheck
.............................................................................................................................................................................. 1 206
6.4.1 2 Request sending result: MqlTradeResult structure
.............................................................................................................................................................................. 1 207
6.4.1 3 Sending a trade request: OrderSend and OrderSendAsync
.............................................................................................................................................................................. 1 21 4
6.4.1 4 Buying and selling operations
.............................................................................................................................................................................. 1 229
6.4.1 5 Modying Stop Loss and/or Take Profit levels of a position
.............................................................................................................................................................................. 1 236
6.4.1 6 Trailing stop
.............................................................................................................................................................................. 1 247
6.4.1 7 Closing a position: full and partial
.............................................................................................................................................................................. 1 256
6.4.1 8 Closing opposite positions: fill and partial
.............................................................................................................................................................................. 1 265
6.4.1 9 Placing a pending order
.............................................................................................................................................................................. 1 276
6.4.20 Modifying a pending order
.............................................................................................................................................................................. 1 287
6.4.21  Deleting a pending order
.............................................................................................................................................................................. 1 290
6.4.22 Getting a list of active orders
.............................................................................................................................................................................. 1 292
6.4.23 Order properties (active and historical)
.............................................................................................................................................................................. 1 296
6.4.24 Functions for reading properties of active orders

--- Page 10 ---
Contents
10.............................................................................................................................................................................. 1 304
6.4.25 Selecting orders by properties
.............................................................................................................................................................................. 1 321 
6.4.26 Getting the list of positions
.............................................................................................................................................................................. 1 323
6.4.27 Position properties
.............................................................................................................................................................................. 1 325
6.4.28 Functions for reading position properties
.............................................................................................................................................................................. 1 335
6.4.29 Deal properties
.............................................................................................................................................................................. 1 339
6.4.30 Selecting orders and deals from history
.............................................................................................................................................................................. 1 341 
6.4.31  Functions for reading order properties from history
.............................................................................................................................................................................. 1 344
6.4.32 Functions for reading deal properties from history
.............................................................................................................................................................................. 1 356
6.4.33 Types of trading transactions
.............................................................................................................................................................................. 1 359
6.4.34 OnTradeTransaction event
.............................................................................................................................................................................. 1 378
6.4.35 Synchronous and asynchronous requests
.............................................................................................................................................................................. 1 391 
6.4.36 OnTrade event
.............................................................................................................................................................................. 1 399
6.4.37 Monitoring trading environment changes
.............................................................................................................................................................................. 1 429
6.4.38 Creating multi-symbol Expert Advisors
.............................................................................................................................................................................. 1 444
6.4.39 Limitations and benefits of Expert Advisors
.............................................................................................................................................................................. 1 445
6.4.40 Creating Expert Advisors in the MQL Wizard
......................................................................................................................................................................................1 449
6.5 Testing and optimization of Expert Advisors
.............................................................................................................................................................................. 1 450
6.5.1  Generating ticks in tester
.............................................................................................................................................................................. 1 458
6.5.2 Time management in the tester: timer, Sleep, GMT
.............................................................................................................................................................................. 1 459
6.5.3 Testing visualization: chart, objects, indicators
.............................................................................................................................................................................. 1 460
6.5.4 Multicurrency testing
.............................................................................................................................................................................. 1 465
6.5.5 Optimization criteria
.............................................................................................................................................................................. 1 466
6.5.6 Getting testing financial statistics: TesterStatistics
.............................................................................................................................................................................. 1 478
6.5.7 OnTester event
.............................................................................................................................................................................. 1 489
6.5.8 Auto-tuning: ParameterGetRange and ParameterSetRange
.............................................................................................................................................................................. 1 496
6.5.9 Group of OnTester events for optimization control
.............................................................................................................................................................................. 1 497
6.5.1 0 Sending data frames from agents to the terminal
.............................................................................................................................................................................. 1 498
6.5.1 1  Getting data frames in terminal
.............................................................................................................................................................................. 1 506
6.5.1 2 Preprocessor directives for the tester
.............................................................................................................................................................................. 1 51 0
6.5.1 3 Managing indicator visibility: TesterHideIndicators
.............................................................................................................................................................................. 1 51 1 
6.5.1 4 Emulation of deposits and withdrawals
.............................................................................................................................................................................. 1 51 5
6.5.1 5 Forced test stop: TesterStop
.............................................................................................................................................................................. 1 51 5
6.5.1 6 Big Expert Advisor example
.............................................................................................................................................................................. 1 558
6.5.1 7 Mathematical calculations
.............................................................................................................................................................................. 1 560
6.5.1 8 Debugging and profiling
.............................................................................................................................................................................. 1 561 
6.5.1 9 Limitations of functions in the tester
..................................................................................................................................................................................................... 1 562
7
Part 7. Advanced language tools
......................................................................................................................................................................................1 562
7.1  Resources
.............................................................................................................................................................................. 1 563
7.1 .1  Describing resources using the #resource directive
.............................................................................................................................................................................. 1 564
7.1 .2 Shared use of resources of different MQL programs
.............................................................................................................................................................................. 1 565
7.1 .3 Resource variables
.............................................................................................................................................................................. 1 569
7.1 .4 Connecting custom indicators as resources
.............................................................................................................................................................................. 1 576
7.1 .5 Dynamic resource creation: ResourceCreate
.............................................................................................................................................................................. 1 581 
7.1 .6 Deleting dynamic resources: ResourceFree
.............................................................................................................................................................................. 1 581 
7.1 .7 Reading and modifying resource data: ResourceReadImage
.............................................................................................................................................................................. 1 592
7.1 .8 Saving images to a file: ResourceSave
.............................................................................................................................................................................. 1 603
7.1 .9 Fonts and text output to graphic resources
.............................................................................................................................................................................. 1 61 6
7.1 .1 0 Application of graphic resources in trading
......................................................................................................................................................................................1 624
7.2 Custom symbols
.............................................................................................................................................................................. 1 625
7.2.1  Creating and deleting custom symbols
.............................................................................................................................................................................. 1 628
7.2.2 Custom symbol properties
.............................................................................................................................................................................. 1 629
7.2.3 Setting margin rates
.............................................................................................................................................................................. 1 630
7.2.4 Configuring quoting and trading sessions
.............................................................................................................................................................................. 1 630
7.2.5 Adding, replacing, and deleting quotes
.............................................................................................................................................................................. 1 639
7.2.6 Adding, replacing, and removing ticks
.............................................................................................................................................................................. 1 666
7.2.7 Translation of order book changes

--- Page 11 ---
Contents
11.............................................................................................................................................................................. 1 672
7.2.8 Custom symbol trading specifics
......................................................................................................................................................................................1 689
7.3 Economic calendar
.............................................................................................................................................................................. 1 689
7.3.1  Basic concepts of the calendar
.............................................................................................................................................................................. 1 696
7.3.2 Getting the list and descriptions of available countries
.............................................................................................................................................................................. 1 698
7.3.3 Querying event types by country and currency
.............................................................................................................................................................................. 1 702
7.3.4 Getting event descriptions by ID
.............................................................................................................................................................................. 1 702
7.3.5 Getting event records by country or currency
.............................................................................................................................................................................. 1 706
7.3.6 Getting event records of a specific type
.............................................................................................................................................................................. 1 709
7.3.7 Reading event records by ID
.............................................................................................................................................................................. 1 71 3
7.3.8 Tracking event changes by country or currency
.............................................................................................................................................................................. 1 723
7.3.9 Tracking event changes by type
.............................................................................................................................................................................. 1 723
7.3.1 0 Filtering events by multiple conditions
.............................................................................................................................................................................. 1 742
7.3.1 1  Transferring calendar database to tester
.............................................................................................................................................................................. 1 765
7.3.1 2 Calendar trading
......................................................................................................................................................................................1 774
7.4 Cryptography
.............................................................................................................................................................................. 1 775
7.4.1  Overview of available information transformation methods
.............................................................................................................................................................................. 1 778
7.4.2 Encryption, hashing, and data packaging: CryptEncode
.............................................................................................................................................................................. 1 789
7.4.3 Data decryption and decompression: CryptDecode
......................................................................................................................................................................................1 795
7.5 Network functions
.............................................................................................................................................................................. 1 796
7.5.1  Sending push notifications
.............................................................................................................................................................................. 1 797
7.5.2 Sending email notifications
.............................................................................................................................................................................. 1 797
7.5.3 Sending files to an FTP server
.............................................................................................................................................................................. 1 798
7.5.4 Data exchange with a web server via HTTP/HTTPS
.............................................................................................................................................................................. 1 81 8
7.5.5 Establishing and breaking a network socket connection
.............................................................................................................................................................................. 1 81 9
7.5.6 Checking socket status
.............................................................................................................................................................................. 1 821 
7.5.7 Setting data send and receive timeouts for sockets
.............................................................................................................................................................................. 1 822
7.5.8 Reading and writing data over an insecure socket connection
.............................................................................................................................................................................. 1 827
7.5.9 Preparing a secure socket connection
.............................................................................................................................................................................. 1 828
7.5.1 0 Reading and writing data over a secure socket connection
......................................................................................................................................................................................1 839
7.6 SQLite database
.............................................................................................................................................................................. 1 841 
7.6.0 Principles of database operations in MQL5
.............................................................................................................................................................................. 1 845
7.6.1  SQL Basics
.............................................................................................................................................................................. 1 849
7.6.2 Structure of tables: data types and restrictions
.............................................................................................................................................................................. 1 852
7.6.3 OOP (MQL5) and SQL integration: ORM concept
.............................................................................................................................................................................. 1 854
7.6.4 Creating, opening, and closing databases
.............................................................................................................................................................................. 1 856
7.6.5 Executing queries without MQL5 data binding
.............................................................................................................................................................................. 1 865
7.6.6 Checking if a table exists in the database
.............................................................................................................................................................................. 1 866
7.6.7 Preparing bound queries: DatabasePrepare
.............................................................................................................................................................................. 1 868
7.6.8 Deleting and resetting prepared queries
.............................................................................................................................................................................. 1 870
7.6.9 Binding data to query parameters: DatabaseBind/Array
.............................................................................................................................................................................. 1 872
7.6.1 0 Executing prepared queries: DatabaseRead/Bind
.............................................................................................................................................................................. 1 874
7.6.1 1  Reading fields separately: DatabaseColumn Functions
.............................................................................................................................................................................. 1 875
7.6.1 2 Examples of CRUD operations in SQLite via ORM objects
.............................................................................................................................................................................. 1 893
7.6.1 3 Transactions
.............................................................................................................................................................................. 1 897
7.6.1 4 Import and export of database tables
.............................................................................................................................................................................. 1 898
7.6.1 5 Printing tables and SQL queries to logs
.............................................................................................................................................................................. 1 899
7.6.1 6 Example of searching for a trading strategy using SQLite
......................................................................................................................................................................................1 91 0
7.7 Development and connection of binary format libraries
.............................................................................................................................................................................. 1 91 1 
7.7.1  Creation of ex5 libraries; export of functions
.............................................................................................................................................................................. 1 91 5
7.7.2 Including libraries; #import of functions
.............................................................................................................................................................................. 1 921 
7.7.3 Library file search order
.............................................................................................................................................................................. 1 921 
7.7.4 DLL connection specifics
.............................................................................................................................................................................. 1 926
7.7.5 Classes and templates in MQL5 libraries
.............................................................................................................................................................................. 1 940
7.7.6 Importing functions from .NET libraries
......................................................................................................................................................................................1 940
7.8 Projects
.............................................................................................................................................................................. 1 942
7.8.1  General rules for working with local projects

--- Page 12 ---
Contents
12.............................................................................................................................................................................. 1 945
7.8.2 Project plan of a web service for copying trades and signals
.............................................................................................................................................................................. 1 946
7.8.3 Nodejs based web server
.............................................................................................................................................................................. 1 948
7.8.4 Theoretical foundations of the WebSockets protocol
.............................................................................................................................................................................. 1 949
7.8.5 Server component of web services based on the WebSocket protocol
.............................................................................................................................................................................. 1 958
7.8.6 WebSocket protocol in MQL5
.............................................................................................................................................................................. 1 968
7.8.7 Client programs for echo and chat services in MQL5
.............................................................................................................................................................................. 1 977
7.8.8 Trading signal service and test web page
.............................................................................................................................................................................. 1 982
7.8.9 Signal service client program in MQL5
......................................................................................................................................................................................1 998
7.9 Native python support
.............................................................................................................................................................................. 1 998
7.9.1  Installing Python and the MetaTrader5 package
.............................................................................................................................................................................. 2001 
7.9.2 Overview of functions of the MetaTrader5 package for Python
.............................................................................................................................................................................. 2003
7.9.3 Connecting a Python script to the terminal and account
.............................................................................................................................................................................. 2004
7.9.4 Error checking: last_error
.............................................................................................................................................................................. 2005
7.9.5 Getting information about a trading account
.............................................................................................................................................................................. 2007
7.9.6 Getting information about the terminal
.............................................................................................................................................................................. 2009
7.9.7 Getting information about financial instruments
.............................................................................................................................................................................. 201 3
7.9.8 Subscribing to order book changes
.............................................................................................................................................................................. 201 5
7.9.9 Reading quotes
.............................................................................................................................................................................. 2020
7.9.1 0 Reading tick history
.............................................................................................................................................................................. 2023
7.9.1 1  Calculating margin requirements and evaluating profits
.............................................................................................................................................................................. 2024
7.9.1 2 Checking and sending a trade order
.............................................................................................................................................................................. 2029
7.9.1 3 Getting the number and list of active orders
.............................................................................................................................................................................. 2032
7.9.1 4 Getting the number and list of open positions
.............................................................................................................................................................................. 2034
7.9.1 5 Reading the history of orders and deals
......................................................................................................................................................................................2038
7.1 0 Built-in support for parallel computing: OpenCL
..................................................................................................................................................................................................... 2046
8
Conclusion

--- Page 13 ---
 
1 3 
MQL5 Programming for Traders
Modern trading relies heavily on computer technology. Automation now extends beyond the boundaries
of exchanges and brokerage offices, becoming accessible to everyday users through specialized
software solutions. Among the pioneers in this field stands MetaTrader, which emerged in the early
2000s. The latest platform version, MetaTrader 5 , remains at the forefront, continuously evolving with
innovative features and functionalities.
A key element continuously refined within MetaTrader 5 is its built-in programming language MQL5. It
enables traders to ascend to a whole new level of trading automation, commonly referred to as
Algorithmic Trading. With MQL5, traders can transform their strategies into applications by writing their
own indicators for analysis, scripts for executing operations, or Expert Advisor for complete trading
automation. Being an automated trading system, an Expert Advisor can operate autonomously, tracking
price changes and promptly alerting traders via email or SMS.
The built-in programming language allows traders to implement virtually any trading concept, from
simple strategies to complex algorithms based on neural networks. MQL5 seamlessly combines the
features of domain-specific and universal programming languages. Over the years, the language has
acquired valuable advancements, such as support for 3D graphics, parallel computations via OpenCL,
Python integration, and SQLite database support.
To unlock the full potential of MetaTrader 5, you must delve into programming. This book will help you
master MQL5 and learn how to create your own trading applications.
It is assumed that the reader is already familiar with MetaTrader 5. Another prerequisite is the
understanding of the fundamental principles of terminal operation within a distributed information
system that facilitates trading. The terminal Help provides detailed information on all available features.
Furthermore, using MQL5 API, traders can access capabilities far beyond the MetaTrader 5 GUI.
Master the programming language to implement complex scenarios, automating various terminal
operation aspects and enhancing trading strategy efficiency.
The book is divided into 7 parts, each focusing on different aspects of MQL5 programming.
•Part 1  introduces basic MQL5 programming principles and MetaEditor, the standard MQL5
framework. Users experienced in programming in other languages should note the features of the
framework.
•Part 2  explains the basic terms, such as types, instructions, operators, expressions, variables, code
blocks, program structures. It describes how these terms are utilized in MQL5 procedural
programming style. Those users who know MQL4 well can skip this part and start reading Part 3.
•Part 3  deals with object oriented programming (OOP) in MQL5. Despite its similarity to other
languages that support the OOP paradigm (especially to C++), MQL5 has certain specific features.
To taste, MQL5 is sort of C±±.
•Part 4  describes common embedded functions which are applicable to in any program.
•Part 5  covers the architectural features of MQL programs and their "majoring" in types to perform
various trading tasks, such as technical analysis using indicators, chart management and marking
the charts with imposing graphical objects onto them, and responses to interactive actions and
events involving MQL programs.
•Part 6  explains how to analyze trading environment and automate trading operations using robots.
This part also presents the program interaction with tester in various modes, including strategy
optimization.

--- Page 14 ---
 
1 4 
•Part 7  contains information regarding the extended set of dedicated APIs facilitating the MQL5
integration with adjacent technologies, such as databases, network data exchange, OpenCL,
Python, etc.
Throughout the book, the material is presented in a balanced manner, combining common approaches,
examples, and technical details. The reader is guided through transitioning from one concept to
another, resembling a chicken-and-egg problem inherent in learning programming. To reinforce
understanding, most MQL programs discussed in the book are available as source codes for practical
exploration in MetaEditor/MetaTrader 5.

--- Page 15 ---
Part 1 . Introduction to MQL5 and development environment
1 5 
Part 1 . Introduction to MQL5 and development environment
One of the most important changes in MQL5 in its reincarnation in MetaTrader 5 is that it supports the
object-oriented programming (OOP) concept. At the time of its appearance, the preceding MQL4 (the
language of MetaTrader 4) was conventionally compared to the C programming language, while it is
more reasonable to liken MQL5 to C++. In all fairness, it should be noted that today all OOP tools that
initially had only been available in MQL5 were transferred into MQL4. However, users who scarcely
know programming still perceive OOP as something too complicated.
In a sense, this book is aiming at making complex things simple. It is not to replace, but to be added to
the MQL5 Language Reference that is supplied with the terminal and also available on the mql5.com
website.
In this book, we are going to consistently tell you about all the components and techniques of
programming in MQL5, taking baby steps so that each iteration is clear and the OOP technology
gradually unlocks its potential that is especially notable, as with any powerful tool, when it is used
properly and reasonably. As a result, the developers of MQL programs will be able to choose a preferred
programming style suitable for a specific task, i.e., not only the object-oriented but also the 'old'
procedural one, as well as use various combinations of them.
Users of the trading terminal can be conveniently classified into "programmers" (those who have
already some experience in programming in at least one language) and "non-programmers" ("pure"
traders interested in the customization capacity of the terminal using MQL5). The former ones can
optionally skip the first and the second parts of this book describing the basic concepts of language and
immediately start learning about the specific APIs (Application Programming Interfaces) embedded in
MetaTrader 5. For the latter ones, progressive reading is recommended.
Among the category of "programmers," those knowing C++ have the best advantages, since MQL5 and
C++ are similar. However, this "medal" has its reverse side. The matter is that MQL5 does not
completely match with C++ (especially when compared to the recent standards). Therefore, attempts
to write one structure or another through habit "as on pluses" will frequently be interrupted by
unexpected errors of the compiler. Considering specific elements of the language, we will do our best to
point out these differences.
Technical analysis, executing trading orders, or integration with external data sources – all these
functions are available to the terminal users both from the user interface and via software tools
embedded in MQL5.
Since MQL5 programs must perform different functions, there are some specialized program types
supported in MetaTrader 5. This is a standard technique in many software systems. For example, in
Windows, along with usual windowing programs, there are command-line-driven programs and services.
The following program types are available in MQL5:
•Indicators – programs aimed at graphically displaying data arrays computed by a given formula,
normally based on the series of quotes;
•Expert Advisors – programs to automate trading completely or partly;
•Scripts – programs intended for performing one action at a time; and
•Services – programs for performing permanent background actions.
We will discuss the purposes and special features of each type in detail later. It is important to note
now that they all are created in MQL5 and have much in common. Therefore, we will start learning with
common features and gradually get to know about the specificity of each type.

--- Page 16 ---
Part 1 . Introduction to MQL5 and development environment
1 6 
The essential technical feature of MetaTrader consists in exerting the entire control in the client
terminal, while commands initiated in it are sent to the server. In other words, MQL-based applications
can only work within the client terminal, most of them requiring a 'live' connection to the server to
function properly. No applications are installed on the server. The server just processes the orders
received from the client terminal and returns the changes in the trading environment. These changes
also become available to MQL5 programs.
Most types of MQL5 programs are executed in the chart context, i.e., to launch a program, you should
'throw' it onto the desired chart. The exception is only a special type, i.e., services: They are intended
for background operation, without being attached to the chart.
We recall that all MQL5 programs are inside the working MetaTrader 5 folder, in the nested folder
named /MQL5/<type> , where <type>  is, respectively:
•Indicators
•Experts
•Scripts
•Services
Based on the MetaTrader 5 installation technique, the path to the working folder can be different
(particularly, with the limited user rights in Windows, in a normal mode or portable). For example, it can
be:
C:/Program Files/MetaTrader 5/
or
C:/Users/<username>/AppData/Roaming/MetaQuotes/Terminal/<instance_id>/
The user can get to know where this folder is located exactly by executing the File -> Open data catalog
command (it is available in both terminal and editor). Moreover, when creating a new program, you
don't need to think of looking up the correct folder due to using the MQL Wizard embedded in the
editor. It is called for by the File -> New  command and allows selecting the required type of the MQL5
program. The relevant text file containing a source code template will be created automatically where
necessary upon completing the Master and then opened for editing.
In the MQL5 folder, there are other nested folders, along with the above ones, and they are also
directly related to MQL5 programming, but we will refer to them later.
MQL5 Programming for Traders – Source Codes from the Book. Part 1 
Examples from the book are also available in the public project  \MQL5\Shared Projects\MQL5Book
1.1 Editing, compiling, and running programs
All MetaTrader 5 programs are compilable. That is, a source code written in MQL5 must be compiled to
obtain the binary representation that will be exactly the one executed in the terminal.
Programs are edited and compiled using MetaEditor.

--- Page 17 ---
Part 1 . Introduction to MQL5 and development environment
1 71 .1  Editing, compiling, and running programs
Editing an MQL program in MetaEditor
Source code is a text written according to the MQL5 rules and saved as a file having the extension of
mq5. The file containing a compiled program will have the same name, while its extension will be ex5.
In the simplest case, one executable file corresponds with one file containing the source code; however,
as we will see later, coding complex programs frequently requires splitting the source code into multiple
files: The main one and some supporting ones that are enabled from the main file in a special manner.
In this case, the main file must still have the extension of mq5, while those enabled from it must have
the extension of mqh. Then statements from all source files will get into the executable file being
generated. Thus, multiple files containing the source code may be the starting point for creating one
executable file/program. All this mentioned here to complete the picture is going to be presented in the
second part of the book.
We will use the term MQL5 syntax to denote the set of all rules that allow constructing programs in
MQL5. Only the strict adherence to the syntax allows coding programs compatible with the compiler. In
fact, teaching to code consists of sequentially introducing all the rules of a particular language that is
MQL5, in our case. And this is the main purpose of this book.
To compile a source code, we can use the command MetaEditor File -> Compile  or just press F7.
However, there are some other, special methods to compile — we will discuss them later. Compiling is
accompanied by displaying the changing status in the editor log (where an MQL5 program consists of
multiple files containing the source code, and enabling each file is marked in a single log line).

--- Page 18 ---
Part 1 . Introduction to MQL5 and development environment
1 81 .1  Editing, compiling, and running programs
Compiling an MQL5 program in MetaEditor
An indication of a successful compilation is zero errors ("0 errors"). Warnings do not affect the
compilation results, they just inform on potential issues. Therefore, it is recommended to fix them on
the same basis as errors (we will tell you later how to do that). Ideally, there should not be any
warnings ("0 warnings").
Upon the successful compilation of an mq5 file, we get a same-name file with the extension of ex5.
MetaTrader 5 Navigator  displays as a tree all executable ex5 files located in folder MQL5 and its
subfolders, including the one just compiled.

--- Page 19 ---
Part 1 . Introduction to MQL5 and development environment
1 91 .1  Editing, compiling, and running programs
MetaTrader 5 Navigator with a compiled MQL5 program
Ready programs are launched in the terminal using any methods familiar to the user. For instance, any
program, other than a service, can be dragged with the mouse from Navigator  to the chart. We will talk
about the features of services separately.
Besides, developers often need the program to be executed in the debugging mode to find what causes
the errors. There are multiple special commands for this purpose, and we will refer to them in Bug fixing
and debugging .
1.2 MQL Wizard and program draft
Here we will consider the simplest MQL program that does not really do anything. It is aimed at
introducing the process of writing a source code in the editor, compiling it, and launching it in the
terminal. Following the steps below independently, you will make sure that programming is available to
casual users and start adapting to the integrated development environment of MQL5 programs. It will
always be needed for consolidating the material covered.
The simplest MQL5 programs are scripts. Therefore, it is a script that we are going to try and create.
For this purpose, let's start MQL5 Wizard ( File -> New ). In the first step, we will select Script  in the list
of types and press Next :

--- Page 20 ---
Part 1 . Introduction to MQL5 and development environment
201 .2 MQL Wizard and program draft
Creating a script using MQL Wizard. Step 1
In the second step, we will introduce the script name in the Name field, having added it after the
default folder mentioned above and a backslash: "Scripts\". For instance, let's name the script
"Hello" (that is, the Name field will contain the line: "Scripts\Hello") and, without changing anything
else, press Finish .


--- Page 21 ---
Part 1 . Introduction to MQL5 and development environment
21 1 .2 MQL Wizard and program draft
Creating a script using MQL Wizard. Step 2
As a result, the Wizard will create a file named Hello.mq5  and open it for editing. The file is located in
folder MQL5/Scripts  (standard location for scripts) because we have used the default folder; however,
we could add any sub-folder or even a sub-folder hierarchy. For instance, if we write
"Scripts\Exercise\Hello" in the Name  field at Wizard Step 1 , then the Exercise  sub-folder will be created
in the Scripts  folder automatically, and the file Hello.mq5  will be located in that sub-folder.
All examples from this book will be located in the MQL5Book folders inside catalogs allocated for the
MQL programs of relevant types. This is necessary to facilitate installing the examples into your
working copy of the terminal and rule out any name conflicts with other MQL programs you have
already installed.
For example, file Hello.mq5 delivered as part of this book is located in MQL5\Scripts\MQL5Book\p1 \,
where p1  means Part 1  this example relates to.
The resulting template of script Hello.mq5  contains the following text:
//+------------------------------------------------------------------+
//|                                                        Hello.mq5 |
//|                                  Copyright 2021, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property  copyright  "Copyright 2021, MetaQuotes Ltd."
#property  link      "https://www.mql5.com"
#property  version   "1.00"
//+------------------------------------------------------------------+
//| Script program start function                                    |
//+------------------------------------------------------------------+
void OnStart()
{
}
//+------------------------------------------------------------------+
It is this script that is shown in the preceding screenshots of MetaEditor and MetaTrader 5.
All strings starting with "//" are the comments and do not affect the program intent. They are neither
processed by the compiler nor executed by the terminal. They are only used to exchange explanatory
information among developers or to visually emphasize the code parts to enhance the text readability.
For instance, in this template, the file starts with a block containing a comment where the script name
and the author's copyright are expected to be specified. The second block of comments is the heading
for the main function of the script – it is referred to in more detail below. Finally, the last comment
string visually emphasizes the file end.
Three strings starting with a special directive, #property , provide the compiler with some attributes it
builds into the program in a special manner. In our case, they are not important so far and can even be
deleted. The specific directories are available to each MQL program type – we will know about them as
soon as we proceed to learning the particular program types.
The main part of the script, where we are going to describe the essence of the program actions, is
represented by the OnStart  function. Here we have to learn the concepts of 'code block' and 'function'.

--- Page 22 ---
Part 1 . Introduction to MQL5 and development environment
221 .3 Statements, code blocks, and functions
1.3 Statements, code blocks, and functions
Thus, in the script generated by the Wizard, the OnStart  function appears as follows:
void OnStart()
{
}
It is exactly our first subject matter within the context of programming in MQL5. Here again, we
immediately encounter unknown concepts and character sequences. To explain them, we shall make a
short digression.
A program must usually implement the following typical stages when running:
•Defining variables, i.e., named cells in the computer memory to store data;
•Organizing the source data input;
•Processing the data – an applied algorithm; and
•Organizing the output of results.
All these stages are not necessary in terms of maintaining the syntactic correctness of the program.
For example, if we create a program that computes the product of "2*2", it obviously does not need
any input data, because numbers necessary for multiplying are integrated in the program text.
Moreover, since 2 and 2 are constant values in this expression, no named cells (variables) are required
in the program. Since we know it anyway what twice two is, we don't really need to communicate the
product number. Such a program would lack any real function, of course. However, it would be
absolutely correct from a technical point of view.
More interestingly, the program may contain no statements on processing. Our script template
specifically represents a sample 'null' program. But what is the above text fragment?
In his day, Niklaus Wirth, one of the big names in programming, gave a simple generalized definition of
programming as a symbiosis of algorithms and data structures.
"Algorithm" shall mean a sequence of statements of a particular programming language. A statement is
a kind of sentence, i.e., a completed utterance, articulated in a programming language according to its
syntax rules. The name "statement" itself suggests that it is perceived by computers as a guide to
operations. In other words, statements describe when and how the required applied data structures
shall be processed. This is exactly why the interpenetration of algorithms and data structures allows
putting the author's ideas into practice.
Unfortunately, in most practical tasks, the number of statements is so large that they must be
systematized somehow for the human to recognize and control the program behavior.
Here too, the divide-and-conquer algorithm comes to help, which is used practically everywhere in
programming and in different guises. We will learn all of them as we continue in this book, now just
noting the essence.
As known, the algorithm reduces to dividing a large complex task into smaller and simpler ones. Here,
we can compare this process with constructing a house or assembling a spacecraft. Both "products"
consist of multiple different modules that, in turn, consist of components, and the latter ones of even
smaller parts, etc.

--- Page 23 ---
Part 1 . Introduction to MQL5 and development environment
231 .3 Statements, code blocks, and functions
Extending this similarity to algorithms, we can say that statements are small parts, while the entire
program is a house/spacecraft. Therefore, we need structural blocks sized intermediately.
This is why it is customary, when implementing algorithms, to combine logically related statements into
larger named fragments, the functions. In the required places of the program, we can address the
function by its name (call it) and doing so, ask the computer to execute all statements contained inside
the function. The entire program is, in fact, the largest external block and therefore, it can also be
presented by the function, from which smaller functions are called or statements are executed
immediately if they are not many. Now we're approaching the OnStart  function.
Name OnStart  is reserved in scripts to denote the ultimate function that is called by the terminal itself
as a response to the user's actions when the user launches the script using the context menu
command or dragging the mouse over the chart. Thus, the preceding fragment of the code defines the
function OnStart  that predetermines the behavior of our entire script.
Those who know programming in other languages, such as C, C++, Rust, or Kotlin, can notice the
similarity of this function with the function main  — the core point of entering into the program.
Any script must contain the function OnStart . Otherwise, the compilation may finish with an error.
Empty function OnStart , as ours, starts being executed by the terminal (as soon as the script is
launched in any manner) and immediately finishes its operation. Strictly speaking, there is no applied
algorithm in our script yet, but there is already a stub function to add it.
In other types of MQL programs, there are also special functions to be defined by the programmer in
their code. We will get into the specific features in the relevant parts of the book.
We will consider the function definition syntax in detail in the second part of this book. For a hands-on
review of it, it is sufficient to mention the following basic essentials to understand the description of
OnStart .
Since functions are usually intended for obtaining an applicable result, the characteristics of the
expected value are described in a special manner in their definition: What data types should be obtained
and whether the data is even necessary. Some functions can perform actions that do not require
returning the value. For example, a function can be intended for changing the settings of the current
chart or to send push notifications when the predefined drawdown level is reached on the account. All
this can be programmed by the statements in the function, and it does not create any new data
(reasonable to be returned to any other parts of the program).
In our case, the situation is similar: As the main function of the script, OnStart  could return its result to
the external environment only (directly into the terminal) when completed, but this would not affect the
operation of the script itself in any way (because it has already finished off).
That is exactly why, before the OnStart  function name, there is the word void that informs the compiler
that the result is not important to us ( void means emptiness). void is one of many procedure words
reserved in MQL5. The compiler knows the meanings of all reserved words, and it is guided by them in
reviewing the source code. Particularly, a programmer may use reserved words to define new terms for
the compiler, such as the function OnStart  itself.
Parentheses after the name are integral to the description of any function: They may enclose the list of
function parameters. For instance, if we were writing a function taking a square of a number, we would
have to provide it with one parameter for that number. Then we could call this function from any part of
the program, having sent one argument over it, i.e., the specific value for the parameter. We will see
later how to describe the list of parameters; it is not in this current example. This requirement is posed

--- Page 24 ---
Part 1 . Introduction to MQL5 and development environment
241 .3 Statements, code blocks, and functions
on the function OnStart  for it is called by the terminal itself, and it never sends anything to this function
as parameters.
At last, braces are used to mark the beginning and the end of the block containing statements.
Immediately following the function name string, such a block will contain a set of operations performed
by this function. It is also named the function body. In this case, there is nothing inside the braces.
Therefore, the script template does not do anything.
The above sequence of word void, name OnStart , an empty list of parameters, and an empty code
block defines the least, empty implementation of the function OnStart  for the compiler. Later, adding
statements into the function body, we will extend the definition of function OnStart .
Having executed the Compile  command, we will make sure that the script can be successfully compiled,
and that the ready program appears in the Navigator  of the terminal in the folder
Scripts/MQL5Book/p1 . This results from the fact that, on the disk in the relevant folder, there is now
the file of Hello.ex5 . It can easily be checked in any file manager.
We can run the script on a chart, but the only confirmation of its execution will be the entries in the
terminal log (tab Log in the Tools  window; not to be mixed with the toolbar):
Scripts script Hello (EURUSD,H1) loaded successfully
Scripts script Hello (EURUSD,H1) removed
That is, the script is loaded, the control is sent to the function OnStart , but immediately returned to
the terminal because the function does not do anything, and after that, the terminal unloaded the
script from the chart.
1.4 First program
Let's try to add to the script something simple but illustrative to demonstrate its operation. Let's
rename the modified script as HelloChart.mq5 .
In many programming textbooks, the initial example prints the sacramental "Hello, world". In MQL5, a
similar greeting could appear as follows:
void OnStart()
{
  Print("Hello, world" );
}
But we will make it more informative:
void OnStart()
{
  Print("Hello, " , Symbol());
}
Thus, we have added only one string with some language structures.
Here, Print  is the name of the function embedded in the terminal and intended to display messages in
the Expert Advisors  log (tab Expert Advisors  in the Tools  window; despite its name Expert Advisors , the
tab collects messages from MQL programs of all types). Unlike the function OnStart  that we are
defining independently, the Print  function is defined for us in advance and forever. Print  is one of many
embedded functions constructing the MQL5 API (application programming interface).

--- Page 25 ---
Part 1 . Introduction to MQL5 and development environment
251 .4 First program
The new line in our code denotes the statement to call the Print  function sending into it the list of
arguments (in parentheses) that will be printed in the log. Arguments in the list are separated by
commas. In this case, there are two arguments: Line "Hello " and call for another embedded function,
Symbol , that returns the name of the active instrument on the current chart (the value obtained from it
will immediately get into the list of arguments of function Print , into the location from which the Symbol
function has been called).
The Symbol  function does not have any parameters and, therefore, nothing is sent into it inside
parentheses.
For instance, if the script is located on the "EURUSD" chart, then calling the function Symbol()  will
return "EURUSD" and, in terms of the program being executed, the statement regarding calling the
function Print  will have a new look: Print("Hello, ", "EURUSD") . From a user's point of view, of course, all
these calls for functions and the dynamic substitution of intermediary results are smooth and
immediate. However, for a programmer, it is important to fully realize how the program is executed
step by step to avoid logical errors and achieve strict compliance with the plan conceived.
The "Hello " line in double quotation marks is referred to as the literal, i.e., a fixed sequence of
characters perceived by the computer as a text, as it is (as it is introduced in the source code of the
program).
Thus, the printing statement above must print the two arguments one by one in the log, which should
result in actually joining the two lines and obtaining "Hello, EURUSD".
Importantly, the comma inside the quotation marks will be printed in the log as a part of the line and is
not processed in any special manner. Unlike that, the comma that is placed after the closing quotation
mark and before calling Symbol()  is the separating character in the argument list, i.e., affects the
program behavior. If the first comma is omitted, the program will not lose its correctness, although it
will print the word "Hello" without a comma after it. However, if the second comma is omitted, the
program will stop being compiled, since the syntax of the function argument list will be broken: All
values in it (in our case, these are two lines) must be separated by commas.
The compiler error will appear as follows:
'Symbol' - some operator expected HelloChart.mq5 1619
The compiler 'complains' of the lack of something before mentioning Symbol . This will break the
compilation, and the executable file of the program is not created. Therefore, we will put the comma
back in place.
This example shows us how important it is to strictly follow the syntax of the language. The same
characters can work differently, being in different parts of the program. Thus, even a small omission
may be critical. For instance, note the semicolon at the end of the line calling Print . The semicolon
means the end of the statement here. If we forget to put it, strange compiler errors may occur.
To see this, we will try to remove this semicolon and re-compile the script. This results in obtaining new
errors with the description of the problem and its place in the source code.

--- Page 26 ---
Part 1 . Introduction to MQL5 and development environment
261 .4 First program
Compilation errors in the MetaEditor log
'}' - semicolon expected HelloChart.mq5 171
'}' - unexpected end of program HelloChart.mq5 171
The first error explicitly specifies the absence of the semicolon expected by the compiler. The second
error is propagated: The closing brace signaling the end of the program had been detected before the
current statement ended. In the compiler's opinion, it continues, because it has not encountered the
semicolon yet. It is obvious how to fix the errors: The semicolon must be placed back in the right
position in the statement.
Let's compile and launch the fixed script. Although it is executed very quickly and removed from the
chart practically immediately and a record confirming the script operation appears in the Experts  log.
HelloChart (EURUSD,H1) Hello, EURUSD
1.5 Data types and values
Along with calling the embedded function Symbol , we could also use our own function that we have
defined in the source code. Suppose we would like to print in the log not just "Hello", but different
greetings depending on the time of day. We will determine the time of day accurate to hours: 0-8 is
morning, 8-1 6 is afternoon, and 1 6-24 is evening.
It is logical to suggest that the definition structure of the new function must be similar to that of the
function OnStart  already familiar to us. However, its name must be unique, i.e., it should not duplicate
the names of other functions or reserved words. We will study the list of these words further in this
textbook, while now luckily suggesting that the word Greeting  can be used as a name.

--- Page 27 ---
Part 1 . Introduction to MQL5 and development environment
271 .5 Data types and values
Like the Symbol  function, this function must return a string; this time, however, the string must be one
of the following phrases, depending on the time of day: "Good morning", "Good afternoon", or "Good
evening".
Guided by common sense, we are using the common concept of string here. Apparently, it is familiar to
the compiler, because we saw how it had generated a program printing the predefined text. Thus, we
have smoothly approached to the concept of types in the programming language, one of the types
being a string, i.e., a sequence of characters.
In MQL5, this type is described by the keyword string . This is the second type we know, the first one
was void. We have already seen a value of this type, without knowing it was that: It is the literal "Hello,
". When we just insert a constant (particularly, something like a quoted text) into the source code, its
type description is not required: defines the correct type automatically.
Using the OnStart  function description as a sample, we can suggest how the function Greeting  should
appear for a first approximation.
string Greeting()
{
}
This text indicates our intention to create the Greeting  function, which can return an arbitrary value of
the string  type. However, for the function to really return something, it is necessary to use a special
statement with the return operator. It is one of many MQL5 operators: We will explore them all later. If
the function has a return value type other than void, it must contain the operator return .
Particularly, to return the former greeting string "Hello, " from the function, we should write:
string Greeting()
{
  return "Hello, " ;
}
Operator return  stops the function execution and sends out what is to the right of it, as a result. "Out"
hides the source code fragment, from which the function was called.
We have not explored all the options for writing expressions that could form an arbitrary string.
However, the simplest instance with the quoted text is transferred here without any changes. It is
important that the return value type coincides with the function type, as in our case. At the end of the
statement, we put a semicolon.
However, we wanted to generate different greetings depending on the time of day. Therefore, the
function must have an hour-defining parameter that can take values ranging from 0 through 23.
Obviously, the hour number is an integer, i.e., a number that has no fractional part. It is clear that the
time does not stop within an hour, and minutes are counted in it, the number of minutes being an
integer, too. Then again, it is pointless to determine the time of day accurately to a minute. Therefore,
we will limit ourselves to choosing the greeting by the hour number only.
For integer values, there is a special type int in MQL5. This value should be sent to the function
Greeting  from another place in the program, from which this function will be called. Here we have first
faced the necessity of describing a named memory cell, that is, a variable.

--- Page 28 ---
Part 1 . Introduction to MQL5 and development environment
281 .6 Variables and identifiers
1.6 Variables and identifiers
A variable is a memory cell having a unique name (to be referred to without any errors), which can
store the values of a certain type. This ability is ensured by the fact that the compiler allocates for the
variable just enough memory that is required for it in the special internal format: Each type is sized and
has a relevant memory storing format. More details on this are given in Part 2.
Basically, there is a stricter term, identifier, in the program, which term is used for the names of
variables, functions, and many other entities to be learned later herein. Identifier follows some rules. In
particular, it may only contain Latin characters, numbers, and underscores; and it may not start with a
number. This is why the word 'Greeting' chosen for the function earlier meets these requirements.
Values of a variable can be different, and they can be changed using special statements during the
program execution.
Along with its type and name, a variable is characterized by the context, i.e., an area in the program,
where it is defined and can be used without any errors of compiler. Our example will probably facilitate
understanding this concept without any detailed technical reasoning in the beginning.
The matter is that a particular instance of a variable is the function parameter. The parameter is
intended for sending a certain value into the function. Hereof it is obvious that the code fragment,
where there is such a variable, must be limited to the body of the function. In other words, the
parameter can be used in all statements inside the function block, but not outside. If the programming
language allowed such liberties, this would become a source of many errors due to the potential
possibility to 'spoil' the function inside from a random program fragment that is not related to the
function.
In any case, it is a slightly simplified definition of a variable, which is sufficient for this introductory
section. We will consider some finer nuances later.
Hence, let's generalize our knowledge of variables and parameters: They must have type, name, and
context. We write the first two characteristics in the code explicitly, while the last one results from the
definition location.
Let's see how we can define the parameter of the hour number in the Greeting  function. We already
know the desired type, it's int, and we can logically choose the name: hour.
string Greeting(int hour)
{
  return "Hello, " ;
}
This function will still return "Hello," whatever the hour. Now we should add some statements that
would select different strings to return, based on the value of parameter hour. Please remember that
there are three possible function response options: "Good morning", "Good afternoon", and "Good
evening". We could suppose that we need 3 variables to describe these strings. However, it is much
more convenient to use an array in such cases, which ensures a unified method of coding algorithms
with access to elements.

--- Page 29 ---
Part 1 . Introduction to MQL5 and development environment
291 .7 Assignment and initialization, expressions and arrays
1.7 Assignment and initialization, expressions and arrays
An array is a named set of same-type cells that are located in memory contiguously, each being
accessible by its index. In a sense, it is a composite variable characterized by a common identifier,
type of values stored, and quantity of numbered elements.
For instance, an array of 5 integers can be described as follows:
int array[5];
Array size is specified in square brackets after the name. Elements are numbered from 0 through N-1 ,
where N is the array size. They are accessed, i.e., the values are read, using a similar syntax. For
example, to print the first element of the above array into the log, we could write the following
statement:
Print(array[0]);
Please note that index 0 corresponds to the very first element. To print the last element, the
statement would be replaced with the following:
Print(array[4]);
It is supposed, of course, that before printing an element of the array, a useful value has once been
written into it. This record is made using a special statement, i.e., assignment operator. A special
feature of this operator is the use of the symbol '=', to the left of which the array element (or variable)
is specified, in which the record is made, while to the right of it the value to be recorded or its
'equivalent' is specified. Here, 'equivalent' hides the language ability to compute expressions of
arithmetic, logic, and other types (we will learn them in Part 2). Syntax of the expressions is mostly
similar to the rules of writing the equations learned in school-time arithmetic and algebra. For example,
operations of addition ('+'), subtraction ('-'), multiplication ('*'), and division ('/') can be used in an
expression.
Below are examples of operators to fill out some elements of the array above.
array[0] = 10;                       // 10
array[1] = array[0] + 1;             // 11
array[2] = array[0] * array[1] + 1;  // 111
These statements demonstrate various methods of assignment and constructing expressions: In the
first string, literal 1 0 is written into element array[0] , while in the second and third lines, the
expressions are used, computing which leads to obtaining the results specified for visual clarity in
comments.
Where array elements (or variables, in a general case) are involved in an expression, the computer
reads their values from memory during program execution and performs the above operations with
them.
It is necessary to distinguish the use of variables and array elements to the left of and to the right of
the '=' character in the assignment statement: On the left, there is a 'receiver' of the processed data
(it is always single), while on the right, there are the 'sources' of initial data for computing (there can
be many 'sources' in an expression, like in the last string of this example, where the values of elements
array[0]  and array[1 ]  are multiplied together).
In our examples, the '=' character was used to assign the values to the elements of a predefined array.
However, it is sometimes convenient to assign initial values to variables and arrays immediately upon

--- Page 30 ---
Part 1 . Introduction to MQL5 and development environment
301 .7 Assignment and initialization, expressions and arrays
defining them. This is called initialization. The '=' character is used for it, too. Let's consider this
syntax in the context of our applied task.
Let's describe the array of strings with the greeting options inside the function Greeting :
string Greeting(int hour)
{
  string messages[3] = {"Good morning" , "Good afternoon" , "Good evening" };
  return "Hello, " ;
}
In the statement added, not only the messages  array with 3 elements is defined, but also its
initialization, i.e., filling with the desired initial values. Initialization highlights the '=' character upon
variable/array name and type description. For a variable, it is necessary to specify only one value after
'=' (without braces), while for an array, as we can see, we can write several values separated by
commas and enclosed in braces.
Do not confuse initialization with assignment. The former is specified in defining a variable/array (and is
made once), while the latter occurs in specific statements (the same variable or array element can be
assigned with different values over and over again). Array elements can only be assigned separately:
MQL5 does not support assigning all elements at a time, as is the case with initialization.
The messages  array, being defined inside the function, is available only inside it, like the parameter
hour. Then we will see how we can describe variables available throughout the program code.
How shall we transform the incoming value of hour with the hour number into one of the three
elements?
Recall that, according to our idea, hour can have values from 0 through 23. If we divide it by 8 exactly,
we will obtain the values from 0 through 2. For instance, dividing 1  by 8 will give us 0, and 7 by 8 will
give 0 (in exact division, the fractional part is neglected). However, dividing 8 by 8 is 1 , so all numbers
through 1 5 will give us 1  when divided by 8. Numbers 1 6-23 will correspond with the division result of
2. Integers 0, 1 , and 2 obtained shall be used as indexes to read the messages  array element.
In MQL5, operation '/' allows computing the exact division for integers.
Expression to obtain the division results is similar to those we have recently considered for the array ,
just the parameter hour and operation '/' must be used. We will use the following statement as a
demonstration of a possible implementation of the hour transformation into the element index:
int index = hour / 8;
Here, a new integer variable, index , is defined and initialized by the value of the above expression.
However, we can omit saving the intermediate value in the index  variable and immediately transfer this
expression (to the right of '=') inside square brackets, where the array element number is specified.
Then in the statement with operator return , we can extract the relevant greeting as follows:

